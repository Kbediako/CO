name: release

on:
  push:
    tags:
      - 'v*.*.*'
      - 'v*.*.*-alpha.*'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build-release:
    runs-on: ubuntu-latest
    outputs:
      tarball: ${{ steps.pack.outputs.tarball }}
      dist_tag: ${{ steps.meta.outputs.dist_tag }}
      prerelease: ${{ steps.meta.outputs.prerelease }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          registry-url: https://registry.npmjs.org/

      - name: Resolve release metadata
        id: meta
        run: |
          TAG="${GITHUB_REF_NAME}"
          if [[ "${TAG}" == *"-alpha."* ]]; then
            echo "dist_tag=alpha" >> "$GITHUB_OUTPUT"
            echo "prerelease=true" >> "$GITHUB_OUTPUT"
          else
            echo "dist_tag=latest" >> "$GITHUB_OUTPUT"
            echo "prerelease=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Ensure tag matches package version
        run: |
          TAG_VERSION="${GITHUB_REF_NAME#v}"
          PKG_VERSION=$(node -e "const pkg=require('./package.json'); console.log(pkg.version);")
          if [[ "${TAG_VERSION}" != "${PKG_VERSION}" ]]; then
            echo "Tag ${GITHUB_REF_NAME} does not match package.json version ${PKG_VERSION}" >&2
            exit 1
          fi

      - run: npm ci
      - run: npm run clean:dist
      - run: npm run build
      - run: npm run pack:audit
      - run: npm run pack:smoke

      - name: Create tarball
        id: pack
        run: |
          PACK_JSON=$(npm pack --json --ignore-scripts)
          echo "$PACK_JSON" > pack.json
          TARBALL=$(node -e "const data=require('./pack.json'); const record=Array.isArray(data)?data[0]:data; console.log(record.filename);")
          echo "tarball=${TARBALL}" >> "$GITHUB_OUTPUT"

      - name: Generate release notes
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          TAG="${GITHUB_REF_NAME}"
          gh api "repos/${GITHUB_REPOSITORY}/releases/generate-notes" \
            -f tag_name="$TAG" \
            -f target_commitish="${GITHUB_SHA}" > release-notes.json
          node - <<'NODE'
          const fs = require('fs');
          const data = JSON.parse(fs.readFileSync('release-notes.json', 'utf8'));
          const body = (data.body || '').trim();

          function extractSection(text, heading) {
            if (!text) return null;
            const lines = text.split('\n');
            const header = `### ${heading}`;
            const start = lines.findIndex((line) => line.trim() === header);
            if (start === -1) return null;
            const collected = [];
            for (let i = start + 1; i < lines.length; i += 1) {
              const line = lines[i];
              if (line.startsWith('### ') || line.startsWith('## ')) {
                break;
              }
              if (line.trim().length === 0 && collected.length === 0) {
                continue;
              }
              collected.push(line);
            }
            const trimmed = collected.join('\n').trim();
            return trimmed.length > 0 ? trimmed : null;
          }

          function extractCompareLine(text) {
            if (!text) return null;
            const line = text.split('\n').find((item) => item.trim().startsWith('**Full Changelog**:'));
            return line && line.trim().length > 0 ? line.trim() : null;
          }

          function stripSection(text, heading) {
            if (!text) return text;
            const lines = text.split('\n');
            const header = `### ${heading}`;
            const start = lines.findIndex((line) => line.trim() === header);
            if (start === -1) return text;
            let end = lines.length;
            for (let i = start + 1; i < lines.length; i += 1) {
              const line = lines[i];
              if (line.startsWith('### ') || line.startsWith('## ')) {
                end = i;
                break;
              }
            }
            return [...lines.slice(0, start), ...lines.slice(end)].join('\n').trim();
          }

          let overview = extractSection(body, 'Overview') ?? '- No labeled overview items.';
          const overridePath = '.github/release-overview.md';
          if (fs.existsSync(overridePath)) {
            const override = fs.readFileSync(overridePath, 'utf8').trim();
            if (override.length > 0) {
              overview = override;
            }
          }
          const bugFixes = extractSection(body, 'Bug Fixes') ?? '- No labeled bug fixes.';
          const compareLine = extractCompareLine(body);
          let bodyWithoutOverview = stripSection(body, 'Overview');
          if (compareLine && !bodyWithoutOverview.includes(compareLine)) {
            bodyWithoutOverview = `${bodyWithoutOverview}\n\n${compareLine}`.trim();
          }
          const full = bodyWithoutOverview.length > 0 ? `## Full Changelog\n\n${bodyWithoutOverview}` : '## Full Changelog\n\nNo changes.';

          const output = [
            '## Release Overview',
            overview,
            '',
            '## Bug Fixes',
            bugFixes,
            '',
            full
          ].join('\n');

          fs.writeFileSync('release-notes.md', output);
          NODE

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          TAG="${GITHUB_REF_NAME}"
          FLAGS=""
          if [[ "${{ steps.meta.outputs.prerelease }}" == "true" ]]; then
            FLAGS="--prerelease"
          fi
          gh release create "$TAG" "${{ steps.pack.outputs.tarball }}" \
            --repo "${GITHUB_REPOSITORY}" \
            --title "$TAG" \
            --notes-file release-notes.md \
            $FLAGS

      - name: Upload tarball artifact (fallback)
        uses: actions/upload-artifact@v4
        with:
          name: release-tarball
          path: ${{ steps.pack.outputs.tarball }}

  publish:
    needs: build-release
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    env:
      TAG: ${{ github.ref_name }}
      DIST_TAG: ${{ needs.build-release.outputs.dist_tag }}
      TARBALL_NAME: ${{ needs.build-release.outputs.tarball }}
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          registry-url: https://registry.npmjs.org/

      - name: Download release asset with gh (preferred)
        id: gh-download
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set +e
          mkdir -p release-assets
          for attempt in 1 2 3; do
            gh release download "$TAG" --repo "$GITHUB_REPOSITORY" --pattern "*.tgz" --dir release-assets
            status=$?
            if [[ $status -eq 0 ]]; then
              echo "downloaded=true" >> "$GITHUB_OUTPUT"
              exit 0
            fi
            sleep $((attempt * 2))
          done
          echo "downloaded=false" >> "$GITHUB_OUTPUT"
          exit 0

      - name: Resolve asset id (fallback)
        if: steps.gh-download.outputs.downloaded != 'true'
        id: asset
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const tag = process.env.TAG;
            const release = await github.rest.repos.getReleaseByTag({ owner, repo, tag });
            const asset = release.data.assets.find(item => item.name.endsWith('.tgz'));
            if (!asset) {
              core.setFailed('No .tgz release asset found.');
              return;
            }
            core.setOutput('asset_id', String(asset.id));
            core.setOutput('asset_name', asset.name);

      - name: Download release asset with curl (fallback)
        if: steps.gh-download.outputs.downloaded != 'true' && steps.asset.outputs.asset_id
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          mkdir -p release-assets
          curl -L \
            -H "Accept: application/octet-stream" \
            -H "Authorization: Bearer ${GH_TOKEN}" \
            -o "release-assets/${{ steps.asset.outputs.asset_name }}" \
            "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/assets/${{ steps.asset.outputs.asset_id }}"

      - name: Download artifact from build (last resort)
        if: steps.gh-download.outputs.downloaded != 'true'
        uses: actions/download-artifact@v4
        with:
          name: release-tarball
          path: release-assets

      - name: Publish to npm
        env:
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          set -euo pipefail
          TARBALL_PATH=$(ls release-assets/*.tgz | head -n 1)
          if [[ -z "$TARBALL_PATH" ]]; then
            echo "No tarball found to publish." >&2
            exit 1
          fi
          if [[ "$TARBALL_PATH" != /* ]]; then
            TARBALL_PATH="$(pwd)/${TARBALL_PATH}"
          fi

          # Prefer trusted publishing (OIDC) so releases do not depend on long-lived tokens.
          set +e
          npm publish "$TARBALL_PATH" --tag "$DIST_TAG" --provenance
          OIDC_STATUS=$?
          set -e
          if [[ $OIDC_STATUS -eq 0 ]]; then
            exit 0
          fi

          echo "OIDC publish failed (exit ${OIDC_STATUS}); falling back to NPM_TOKEN if available."
          if [[ -z "${NPM_TOKEN:-}" ]]; then
            echo "::error::Publish failed via OIDC and secrets.NPM_TOKEN is not set. Configure npm trusted publishing for this package or set an npm automation token in secrets.NPM_TOKEN."
            exit "$OIDC_STATUS"
          fi

          PUBLISH_LOG="$(mktemp)"
          set +e
          NODE_AUTH_TOKEN="$NPM_TOKEN" npm publish "$TARBALL_PATH" --tag "$DIST_TAG" 2>&1 | tee "$PUBLISH_LOG"
          TOKEN_STATUS=${PIPESTATUS[0]}
          set -e
          if [[ $TOKEN_STATUS -ne 0 ]] && grep -q "npm error code EOTP" "$PUBLISH_LOG"; then
            echo "::error::secrets.NPM_TOKEN requires OTP. Use an npm automation token or configure npm trusted publishing for this package."
          fi
          exit "$TOKEN_STATUS"
