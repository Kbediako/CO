name: release

on:
  push:
    tags:
      - 'v*.*.*'
      - 'v*.*.*-*'
  workflow_dispatch:
    inputs:
      tag:
        description: 'Existing release tag to publish (vX.Y.Z or vX.Y.Z-prerelease.N)'
        required: false
        type: string

permissions:
  contents: write

jobs:
  build-release:
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.meta.outputs.tag }}
      tag_version: ${{ steps.meta.outputs.tag_version }}
      tag_sha: ${{ steps.meta.outputs.tag_sha }}
      tarball: ${{ steps.pack.outputs.tarball }}
      dist_tag: ${{ steps.meta.outputs.dist_tag }}
      prerelease: ${{ steps.meta.outputs.prerelease }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          registry-url: https://registry.npmjs.org/

      - name: Resolve release metadata
        id: meta
        run: |
          set -euo pipefail
          TAG=""
          if [[ "${GITHUB_EVENT_NAME}" == "workflow_dispatch" ]]; then
            INPUT_TAG="${{ inputs.tag }}"
            if [[ -n "${INPUT_TAG}" ]]; then
              TAG="${INPUT_TAG}"
            elif [[ "${GITHUB_REF_TYPE}" == "tag" ]]; then
              TAG="${GITHUB_REF_NAME}"
            else
              echo "::error::workflow_dispatch requires a tag ref or inputs.tag (example: v0.1.17)." >&2
              exit 1
            fi
          else
            TAG="${GITHUB_REF_NAME}"
          fi

          TAG="${TAG#refs/tags/}"
          if [[ ! "${TAG}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[0-9A-Za-z][0-9A-Za-z.-]*)?$ ]]; then
            echo "::error::Invalid release tag '${TAG}'. Expected vX.Y.Z or vX.Y.Z-prerelease." >&2
            exit 1
          fi

          if ! git rev-parse --verify "refs/tags/${TAG}" >/dev/null 2>&1; then
            echo "::error::Tag ${TAG} is not available in this checkout." >&2
            exit 1
          fi

          TAG_VERSION="${TAG#v}"
          TAG_SHA="$(git rev-list -n 1 "${TAG}")"
          echo "tag=${TAG}" >> "$GITHUB_OUTPUT"
          echo "tag_version=${TAG_VERSION}" >> "$GITHUB_OUTPUT"
          echo "tag_sha=${TAG_SHA}" >> "$GITHUB_OUTPUT"

          if [[ "${TAG_VERSION}" == *-* ]]; then
            PRERELEASE_LABEL="${TAG_VERSION#*-}"
            DIST_TAG_RAW="${PRERELEASE_LABEL%%[.-]*}"
            DIST_TAG="$(printf '%s' "${DIST_TAG_RAW}" | tr '[:upper:]' '[:lower:]' | tr -cs 'a-z0-9._-' '-')"
            DIST_TAG="${DIST_TAG#-}"
            DIST_TAG="${DIST_TAG%-}"
            if [[ -z "${DIST_TAG}" || "${DIST_TAG}" =~ ^[0-9] ]]; then
              DIST_TAG="next"
            fi
            echo "dist_tag=${DIST_TAG}" >> "$GITHUB_OUTPUT"
            echo "prerelease=true" >> "$GITHUB_OUTPUT"
          else
            echo "dist_tag=latest" >> "$GITHUB_OUTPUT"
            echo "prerelease=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Checkout release tag commit
        run: |
          set -euo pipefail
          TAG="${{ steps.meta.outputs.tag }}"
          # actions/checkout can peel tag refs to the commit SHA on tag push events.
          # Refetching the tag ref restores the annotated tag object for verification.
          git fetch --force origin "refs/tags/${TAG}:refs/tags/${TAG}"
          git checkout --detach "refs/tags/${TAG}"

      - name: Configure tag verification keys
        env:
          RELEASE_SIGNING_PUBLIC_KEYS: ${{ secrets.RELEASE_SIGNING_PUBLIC_KEYS }}
          RELEASE_SIGNING_ALLOWED_SIGNERS: ${{ secrets.RELEASE_SIGNING_ALLOWED_SIGNERS }}
        run: |
          set -euo pipefail
          if [[ -n "${RELEASE_SIGNING_PUBLIC_KEYS:-}" && -n "${RELEASE_SIGNING_ALLOWED_SIGNERS:-}" ]]; then
            echo "::error::Set only one signing secret: RELEASE_SIGNING_PUBLIC_KEYS (GPG) or RELEASE_SIGNING_ALLOWED_SIGNERS (SSH)." >&2
            exit 1
          fi
          configured=0
          if [[ -n "${RELEASE_SIGNING_PUBLIC_KEYS:-}" ]]; then
            printf '%s\n' "${RELEASE_SIGNING_PUBLIC_KEYS}" | gpg --batch --import
            configured=1
          fi
          if [[ -n "${RELEASE_SIGNING_ALLOWED_SIGNERS:-}" ]]; then
            mkdir -p "${RUNNER_TEMP}/signing"
            ALLOWED_SIGNERS_FILE="${RUNNER_TEMP}/signing/allowed_signers"
            printf '%s\n' "${RELEASE_SIGNING_ALLOWED_SIGNERS}" > "${ALLOWED_SIGNERS_FILE}"
            git config --global gpg.format ssh
            git config --global gpg.ssh.allowedSignersFile "${ALLOWED_SIGNERS_FILE}"
            configured=1
          fi
          if [[ "${configured}" -ne 1 ]]; then
            echo "::error::Missing signing verification material. Set RELEASE_SIGNING_PUBLIC_KEYS (GPG) or RELEASE_SIGNING_ALLOWED_SIGNERS (SSH) repository secrets." >&2
            exit 1
          fi

      - name: Enforce signed annotated tag
        run: |
          set -euo pipefail
          TAG="${{ steps.meta.outputs.tag }}"
          TAG_TYPE="$(git cat-file -t "refs/tags/${TAG}" 2>/dev/null || true)"
          if [[ "${TAG_TYPE}" != "tag" ]]; then
            echo "::error::Tag ${TAG} is lightweight. Create a signed annotated tag." >&2
            exit 1
          fi
          TAG_PAYLOAD="$(git cat-file -p "refs/tags/${TAG}")"
          if ! printf '%s\n' "${TAG_PAYLOAD}" | grep -Eq '^-----BEGIN (PGP|SSH) SIGNATURE-----'; then
            echo "::error::Tag ${TAG} is not cryptographically signed." >&2
            exit 1
          fi
          if git verify-tag "${TAG}" >/dev/null 2>&1; then
            echo "Tag ${TAG} signature verified."
          else
            echo "::error::Tag ${TAG} signature verification failed." >&2
            exit 1
          fi

      - name: Ensure tag matches package version
        run: |
          TAG_VERSION="${{ steps.meta.outputs.tag_version }}"
          PKG_VERSION=$(node -e "const pkg=require('./package.json'); console.log(pkg.version);")
          if [[ "${TAG_VERSION}" != "${PKG_VERSION}" ]]; then
            echo "Tag ${{ steps.meta.outputs.tag }} does not match package.json version ${PKG_VERSION}" >&2
            exit 1
          fi

      - run: npm ci
      - run: npm run clean:dist
      - run: npm run build
      - run: npm run pack:audit
      - run: npm run pack:smoke

      - name: Create tarball
        id: pack
        run: |
          PACK_JSON=$(npm pack --json --ignore-scripts)
          echo "$PACK_JSON" > pack.json
          TARBALL=$(node -e "const data=require('./pack.json'); const record=Array.isArray(data)?data[0]:data; console.log(record.filename);")
          echo "tarball=${TARBALL}" >> "$GITHUB_OUTPUT"

      - name: Generate release notes
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          TAG="${{ steps.meta.outputs.tag }}"
          gh api "repos/${GITHUB_REPOSITORY}/releases/generate-notes" \
            -f tag_name="$TAG" \
            -f target_commitish="${{ steps.meta.outputs.tag_sha }}" > release-notes.json
          node - <<'NODE'
          const fs = require('fs');
          const data = JSON.parse(fs.readFileSync('release-notes.json', 'utf8'));
          const body = (data.body || '').trim();

          function extractSection(text, heading) {
            if (!text) return null;
            const lines = text.split('\n');
            const header = `### ${heading}`;
            const start = lines.findIndex((line) => line.trim() === header);
            if (start === -1) return null;
            const collected = [];
            for (let i = start + 1; i < lines.length; i += 1) {
              const line = lines[i];
              if (line.startsWith('### ') || line.startsWith('## ')) {
                break;
              }
              if (line.trim().length === 0 && collected.length === 0) {
                continue;
              }
              collected.push(line);
            }
            const trimmed = collected.join('\n').trim();
            return trimmed.length > 0 ? trimmed : null;
          }

          function extractCompareLine(text) {
            if (!text) return null;
            const line = text.split('\n').find((item) => item.trim().startsWith('**Full Changelog**:'));
            return line && line.trim().length > 0 ? line.trim() : null;
          }

          function stripSection(text, heading) {
            if (!text) return text;
            const lines = text.split('\n');
            const header = `### ${heading}`;
            const start = lines.findIndex((line) => line.trim() === header);
            if (start === -1) return text;
            let end = lines.length;
            for (let i = start + 1; i < lines.length; i += 1) {
              const line = lines[i];
              if (line.startsWith('### ') || line.startsWith('## ')) {
                end = i;
                break;
              }
            }
            return [...lines.slice(0, start), ...lines.slice(end)].join('\n').trim();
          }

          let overview = extractSection(body, 'Overview') ?? '- No labeled overview items.';
          const overridePath = '.github/release-overview.md';
          if (fs.existsSync(overridePath)) {
            const override = fs.readFileSync(overridePath, 'utf8').trim();
            if (override.length > 0) {
              overview = override;
            }
          }
          const bugFixes = extractSection(body, 'Bug Fixes') ?? '- No labeled bug fixes.';
          const compareLine = extractCompareLine(body);
          let bodyWithoutOverview = stripSection(body, 'Overview');
          if (compareLine && !bodyWithoutOverview.includes(compareLine)) {
            bodyWithoutOverview = `${bodyWithoutOverview}\n\n${compareLine}`.trim();
          }
          const full = bodyWithoutOverview.length > 0 ? `## Full Changelog\n\n${bodyWithoutOverview}` : '## Full Changelog\n\nNo changes.';

          const output = [
            '## Release Overview',
            overview,
            '',
            '## Bug Fixes',
            bugFixes,
            '',
            full
          ].join('\n');

          fs.writeFileSync('release-notes.md', output);
          NODE

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          TAG="${{ steps.meta.outputs.tag }}"
          FLAGS=""
          if [[ "${{ steps.meta.outputs.prerelease }}" == "true" ]]; then
            FLAGS="--prerelease"
          fi
          gh release create "$TAG" "${{ steps.pack.outputs.tarball }}" \
            --repo "${GITHUB_REPOSITORY}" \
            --title "$TAG" \
            --notes-file release-notes.md \
            $FLAGS

      - name: Upload tarball artifact (fallback)
        uses: actions/upload-artifact@v4
        with:
          name: release-tarball
          path: ${{ steps.pack.outputs.tarball }}

  publish:
    needs: build-release
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    env:
      TAG: ${{ needs.build-release.outputs.tag }}
      TAG_VERSION: ${{ needs.build-release.outputs.tag_version }}
      DIST_TAG: ${{ needs.build-release.outputs.dist_tag }}
      TARBALL_NAME: ${{ needs.build-release.outputs.tarball }}
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: 22
          registry-url: https://registry.npmjs.org/

      - name: Ensure npm trusted publishing prerequisites
        run: |
          npm install --global npm@^11.5.1
          node --version
          npm --version

      - name: Download release asset with gh (preferred)
        id: gh-download
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set +e
          mkdir -p release-assets
          for attempt in 1 2 3; do
            gh release download "$TAG" --repo "$GITHUB_REPOSITORY" --pattern "*.tgz" --dir release-assets
            status=$?
            if [[ $status -eq 0 ]]; then
              echo "downloaded=true" >> "$GITHUB_OUTPUT"
              exit 0
            fi
            sleep $((attempt * 2))
          done
          echo "downloaded=false" >> "$GITHUB_OUTPUT"
          exit 0

      - name: Resolve asset id (fallback)
        if: steps.gh-download.outputs.downloaded != 'true'
        id: asset
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const tag = process.env.TAG;
            const release = await github.rest.repos.getReleaseByTag({ owner, repo, tag });
            const asset = release.data.assets.find(item => item.name.endsWith('.tgz'));
            if (!asset) {
              core.setFailed('No .tgz release asset found.');
              return;
            }
            core.setOutput('asset_id', String(asset.id));
            core.setOutput('asset_name', asset.name);

      - name: Download release asset with curl (fallback)
        if: steps.gh-download.outputs.downloaded != 'true' && steps.asset.outputs.asset_id
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          mkdir -p release-assets
          curl -L \
            -H "Accept: application/octet-stream" \
            -H "Authorization: Bearer ${GH_TOKEN}" \
            -o "release-assets/${{ steps.asset.outputs.asset_name }}" \
            "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/assets/${{ steps.asset.outputs.asset_id }}"

      - name: Download artifact from build (last resort)
        if: steps.gh-download.outputs.downloaded != 'true'
        uses: actions/download-artifact@v4
        with:
          name: release-tarball
          path: release-assets

      - name: Verify release tarball availability
        run: |
          set -euo pipefail
          if ! ls release-assets/*.tgz >/dev/null 2>&1; then
            echo "::error::Release asset download did not produce a .tgz tarball for ${TAG}."
            echo "::error::Check release asset upload/download steps before publish."
            exit 1
          fi

      - name: Publish to npm
        env:
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          set -euo pipefail
          TARBALL_PATH=$(ls release-assets/*.tgz | head -n 1)
          if [[ -z "$TARBALL_PATH" ]]; then
            echo "No tarball found to publish." >&2
            exit 1
          fi
          if [[ "$TARBALL_PATH" != /* ]]; then
            TARBALL_PATH="$(pwd)/${TARBALL_PATH}"
          fi

          # Prefer trusted publishing (OIDC) so releases do not depend on long-lived tokens.
          # Use a temporary token-free npmrc to avoid accidental NODE_AUTH_TOKEN-based auth.
          OIDC_NPMRC="$(mktemp)"
          printf 'registry=https://registry.npmjs.org/\n' > "$OIDC_NPMRC"
          set +e
          NODE_AUTH_TOKEN= NPM_CONFIG_USERCONFIG="$OIDC_NPMRC" npm publish "$TARBALL_PATH" --tag "$DIST_TAG" --provenance
          OIDC_STATUS=$?
          set -e
          rm -f "$OIDC_NPMRC"
          if [[ $OIDC_STATUS -eq 0 ]]; then
            exit 0
          fi

          echo "OIDC publish failed (exit ${OIDC_STATUS}); falling back to NPM_TOKEN if available."
          if [[ -z "${NPM_TOKEN:-}" ]]; then
            echo "::error::Publish failed via OIDC and secrets.NPM_TOKEN is not set. Configure npm trusted publishing for this package or set an npm automation token in secrets.NPM_TOKEN."
            exit "$OIDC_STATUS"
          fi

          PUBLISH_LOG="$(mktemp)"
          set +e
          NODE_AUTH_TOKEN="$NPM_TOKEN" npm publish "$TARBALL_PATH" --tag "$DIST_TAG" 2>&1 | tee "$PUBLISH_LOG"
          TOKEN_STATUS=${PIPESTATUS[0]}
          set -e
          if [[ $TOKEN_STATUS -ne 0 ]] && grep -q "npm error code EOTP" "$PUBLISH_LOG"; then
            echo "::error::secrets.NPM_TOKEN requires OTP. Use an npm automation token or configure npm trusted publishing for this package."
          fi
          exit "$TOKEN_STATUS"
